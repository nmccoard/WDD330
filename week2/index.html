<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta name="author" content="Nathan McCoard">
   <title>WDD 330 Week 1 Notes</title>

   <link rel="stylesheet" href="../css/styles.css"/>
</head>

<body>
   <h1 class="title">Nate's Week 2 Notes</h1>
   <ul>
      <lh><strong>Code Examples</strong></lh>
      <li><a href="example.html">Playing with Examples from the reading</a></li>
      <li><a href="../quizNinja/">Quiz Ninja</a></li>
   </ul>
   <ul>
      <lh><strong>Novice to Ninja Chapter 2 - Programming Basics</strong></lh>
      <li>Variables declared using const and let will have local scope and only available in the block they where created in. Var or not using keyword will have a global scope (very problematic) so avoid using them.</li>
      <li>When naming constants and variables, you should try to give them sensible names that describe what the variable represents</li>
      <li>Probably the best convention for naming variables and functions if to use camel-case. This follows the same notation used with JS's built in functions.</li>
      <li>Assigning primitive type values to a variable is done directly.</li>
      <li>Non-primitive types (objects) assignments are done by reference. So any changes to the variable will change the object every where and not limited by scope.</li>
      <li>,indexOf() will return a -1 if the character does not exist in a string (I did not know this).</li>
      <li>Remember .startsWith() and .endsWith() are case sensitive.</li>
      <li>I don't get what the use case is for symbol?</li>
      <li>In general, values tend to be set to undefined by JavaScript, whereas values are usually set to null manually by the programmer.</li>
      <li>Remember when checking if strings are < or > upper-case letters are considered to be "less than" lower-case letters and is done in alphabetic order.</or></li>
      <br>
      <lh><strong>Chapter 3 - Arrays, Logic, and Loops</strong></lh>
      <li>Deleting something from an array will not reduce the length of the arry, because the removed value will be replaced with undefined and not removed.</li>
      <li>To remove something from the array we could use pop to remove it off the end or the array or we could use shift to take it off the front. But if we need to remove something from the middle we would need to us splice (like this avengers.splice(1, 1) the first number is the position in the array and the second number is the number of thing to be removed. Splice and also be used to add things in the middle of an array by using a third argument for the value to be added.</li>
      <li>I need to work on using more Ternary Operators in place of simple if / else statements. [condition <strong>?</strong> run this if true <strong>:</strong> else do this;] </li>
      <li>When looping over arrays it better to do this <strong>for(let i=0, max=avengers.length; i < max; i++)</strong> over this <strong>for(let i=0;  i< avengers.length; i++)</strong> </li>
      <li>Use for of loops to simplify looping over arrays [<strong>for</strong>(const varName <strong>of</strong> array)]</li>
      <li>Why does the variable in the for of loop need to be declared using const?</li>
      <br>
      <lh><strong>Chapter 4 - Functions</strong></lh>
      <li>Default parameters should always come after non-default parameters.If not then you will need to enter the default value any way. Remember position matters, the first argument will always go to the first parameter.</li>
      <li>Arrow functions are always anonymous, so if you want to refer to them, you must assign them to a variable. The parameters come before the arrow and the main body of the function comes after. [const test = x <strong>=></strong> x*x]</li>
      <li>The return keyword isn’t required if the return statement is the only statement in the body of the arrow function (like above).</li>
      <li>If the function doesn’t require any parameters, a pair of empty parentheses must go before the arrow</li>
      <li>Arrow functions are frequently used to declare short functions, that only taking up one line.</li>
      <li>Function and variable hoisting is a JavaScript interpreter's action of move their declarations to the top of the current scope.</li>
      <li>Function Hoisting is what lets us call a function before it has been defined.</li>
      <li>Variable Hoisting only works with var. best practice it to use let and const and declare any variables at the top of the code block they are used in. This will help prevent weird errors caused by vars being undefined</li>
      <li>functions can also be given as a parameter to another function. A function that is passed as an argument to another is known as a callback.</li>
      <li>Chaining iterator functions works because they return arrays, which means that another iterator function can then be chained on to the end and it will be applied to the new array.</li>
      <li>Refactoring is the process of improving the code’s structure and maintainability without changing its behavior.</li>

   </ul>
</body>
</html>